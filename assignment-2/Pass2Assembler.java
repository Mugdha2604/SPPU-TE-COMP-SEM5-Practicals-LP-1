

import java.io.*;
import java.util.*;

public class Pass2Assembler {
    // Map to store: symbol_index -> address
    static Map<Integer, Integer> symtab = new HashMap<>();
    // Map to store: literal_index -> address
    static Map<Integer, Integer> littab = new HashMap<>();
    // List to store the final generated machine code lines
    static List<String> machineCode = new ArrayList<>();

    public static void main(String[] args) {
        try {
            // Step 1: Load the tables generated by Pass 1
            loadSymbolTable("./symtab.txt");
            loadLiteralTable("./littab.txt");

            // Step 2: Process the intermediate code using the loaded tables
            processIC("./intermediate_code.txt");

            // Step 3: Write the final machine code to a file and display it
            writeMachineCode("./machinecode.txt");

        } catch (Exception e) {
            System.err.println("Error during Pass 2 execution: " + e.getMessage());
            e.printStackTrace();
        }
    }

    /**
     * Reads symtab.txt and loads the symbol index and its address into the symtab map.
     * Expected format: index [symbol_name] address
     */
    static void loadSymbolTable(String filename) throws IOException {
        BufferedReader br = new BufferedReader(new FileReader(filename));
        String line;
        while ((line = br.readLine()) != null) {
            String[] parts = line.trim().split("\\s+");
            // --- START FIX: Make loader more robust ---
            // Works for "index address" and "index name address"
            if (parts.length >= 2) { 
                int index = Integer.parseInt(parts[0]);
                int addr = Integer.parseInt(parts[parts.length - 1]); // Get last part
                symtab.put(index, addr);
            }
            // --- END FIX ---
        }
        br.close();
        System.out.println("✅ Symbol Table loaded successfully.");
    }

    /**
     * Reads littab.txt and loads the literal index and its address into the littab map.
     * Expected format: index [literal_value] address
     */
    static void loadLiteralTable(String filename) throws IOException {
        BufferedReader br = new BufferedReader(new FileReader(filename));
        String line;
        while ((line = br.readLine()) != null) {
            String[] parts = line.trim().split("\\s+");
            // --- START FIX: Make loader more robust ---
            if (parts.length >= 2) { 
                int index = Integer.parseInt(parts[0]);
                int addr = Integer.parseInt(parts[parts.length - 1]); // Get last part
                littab.put(index, addr);
            }
            // --- END FIX ---
        }
        br.close();
        System.out.println("✅ Literal Table loaded successfully.");
    }

    /**
     * Reads ic.txt, processes each line, and generates the corresponding machine code.
     */
    static void processIC(String filename) throws IOException {
        BufferedReader br = new BufferedReader(new FileReader(filename));
        String line;
        int lc = 0; // Location Counter

        while ((line = br.readLine()) != null) {
            line = line.trim();
            // Skip empty lines or header/footer lines
            if (line.isEmpty() || line.startsWith("-----")) continue;

            // Robust parser for formats like (IS,4) (R,1) (S,2) or (AD,03) (S,02)+2
            String[] tokens = line.split("\\)\\s*\\(");
            tokens[0] = tokens[0].substring(1); // Remove leading '('
            if (tokens.length > 0) {
                 tokens[tokens.length - 1] = tokens[tokens.length - 1].replace(")", ""); // Remove trailing ')'
            }

            String[] firstPart = tokens[0].split(",");
            String type = firstPart[0].trim(); 
            int code = Integer.parseInt(firstPart[1].trim()); 

            if (type.equals("AD")) {
                // --- Assembler Directives ---
                if (code == 1) { // START
                    if (tokens.length > 1) {
                        lc = Integer.parseInt(tokens[1].split(",")[1].trim()); 
                    } else {
                        System.err.println("Warning: START directive (AD,01) found without address. Assuming LC=0.");
                    }
                }
                // --- START FIX: Handle ORIGIN ---
                else if (code == 3) { // ORIGIN
                    if (tokens.length > 1) {
                        String operand = tokens[1].trim(); // e.g., "S,02+2"
                        int newLc = 0;
                        try {
                            if (operand.contains("+")) {
                                String[] parts = operand.split("\\+");
                                String symbolPart = parts[0]; // "S,02"
                                int constant = Integer.parseInt(parts[1]); // "2"
                                int symIndex = Integer.parseInt(symbolPart.split(",")[1]); // 2
                                newLc = symtab.get(symIndex) + constant;
                            } else if (operand.contains("-")) {
                                String[] parts = operand.split("-");
                                String symbolPart = parts[0]; // "S,02"
                                int constant = Integer.parseInt(parts[1]); // "2"
                                int symIndex = Integer.parseInt(symbolPart.split(",")[1]); // 2
                                newLc = symtab.get(symIndex) - constant;
                            } else {
                                // Assume it's just a symbol, e.g., "S,02"
                                int symIndex = Integer.parseInt(operand.split(",")[1]); // 2
                                newLc = symtab.get(symIndex);
                            }
                            lc = newLc; // Set the location counter
                        } catch (Exception e) {
                            System.err.println("Error parsing ORIGIN directive: " + line);
                        }
                    }
                }
                // --- END FIX ---
                // END (02), LTORG (04), EQU (05) do not generate machine code in Pass 2.
                continue;

            } else if (type.equals("DL")) {
                // --- Declarative Statements ---
                if (tokens.length < 2) {
                    System.err.println("Warning: Malformed DL statement. Skipping: " + line);
                    continue;
                }
                
                String valueStr = tokens[1].split(",")[1].trim().replaceAll("'", ""); 
                int value = Integer.parseInt(valueStr);

                if (code == 2) { // DS (Declare Storage)
                    lc += value;
                } else if (code == 1) { // DC (Define Constant)
                    String mcode = String.format("%03d) 00 0 %03d", lc, value);
                    machineCode.add(mcode);
                    lc++;
                }

            } else if (type.equals("IS")) {
                // --- Imperative Statements ---
                int opcode = code;
                int regCode = 0;
                int memAddr = 0;

                for (int i = 1; i < tokens.length; i++) {
                    String[] part = tokens[i].split(",");

                    if (part.length == 2) { // e.g., (S, 2)
                        String operandType = part[0].trim();
                        int operandVal = Integer.parseInt(part[1].trim());

                        if (operandType.equals("R") || operandType.equals("CC")) {
                            regCode = operandVal;
                        } else if (operandType.equals("S")) {
                            memAddr = symtab.getOrDefault(operandVal, 0); 
                        } else if (operandType.equals("L")) {
                            memAddr = littab.getOrDefault(operandVal, 0); 
                        }
                    } else if (part.length == 1) { // e.g., (1)
                        try {
                            regCode = Integer.parseInt(part[0].trim());
                        } catch (NumberFormatException e) {
                            System.err.println("Warning: Skipping unparseable operand token: " + tokens[i]);
                        }
                    }
                }

                String mcode = String.format("%03d) %02d %d %03d", lc, opcode, regCode, memAddr);
                machineCode.add(mcode);
                lc++;
            }
        }
        br.close();
        System.out.println("✅ Intermediate Code processed.");
    }

    /**
     * Writes the generated machine code to the specified file and also prints it to the console.
     */
    static void writeMachineCode(String filename) throws IOException {
        try (BufferedWriter bw = new BufferedWriter(new FileWriter(filename))) {
            System.out.println("\n--- FINAL MACHINE CODE ---");
            for (String mcode : machineCode) {
                System.out.println(mcode);
                bw.write(mcode);
                bw.newLine();
            }
            System.out.println("--------------------------");
            System.out.println("✅ Machine code written to " + filename);
        }
    }
}